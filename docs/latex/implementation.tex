\clearpage
\section{Implementation}

\subsection{Base System}

\subsubsection{Peripherals}
The system uses several peripherals that require additional hardware configuration.

% TODO rpi-config
% TODO that one overlay
% TODO disabling logs

\subsubsection{Networking}

The system has a static address ethernet port, as well as a \verb|CAN| network interface.\\

On a modern system this configuration is usually done either using \verb|systemd-networkd| or \verb|NetworkManager|.
These tools are very powerful and user-friendly, but unnecessarily large for embedded applications.\\

This system uses a light-weight legacy method. It's configured using \verb|ifup/ifdown| via \verb|/etc/network/interfaces| file.

\begin{lstlisting}
# Loopback
auto lo
iface lo inet loopback

# Static IP address
allow-hotplug eth0
iface eth0 inet static
    address 192.168.1.100
    netmask 255.255.255.0
    gateway 192.168.1.1

# CAN configuration
auto can0
iface can0 inet manual
    pre-up ip link set can0 type can bitrate 500000 restart-ms 100
    up ip link set can0 up
    down ip link set can0 down
\end{lstlisting}

For debugging purposes the system allows connecting over \verb|SSH|.
It uses \verb|Dropbear|, a minimal \verb|SSH Server|.\\

The interface has a static address of \verb|192.168.1.100 /24|.
To make the interface hotpluggable \verb|ifplugd| was used with the following config file.

\begin{lstlisting}
INTERFACES="eth0"
HOTPLUG_INTERFACES="eth0"
ARGS="-q -f -u0 -d10 -w -I"
SUSPEND_ACTION="stop"
\end{lstlisting}

In order to use this custom configuration file it was necessary to append to the original recipe with a \verb|ifplugd_%.bbappend| file.
\begin{lstlisting}
FILESEXTRAPATHS:prepend := "${THISDIR}/files:"

SRC_URI += "file://ifplugd"

do_install:append() {
    install -d ${D}${sysconfdir}/default
    install -m 0644 ${WORKDIR}/ifplugd ${D}${sysconfdir}/default/ifplugd
}

FILES:${PN} += "${sysconfdir}/default/ifplugd"
\end{lstlisting}

% TODO describe adding password to user for SSH server

\subsubsection{Graphical interface}
During the development of the project a possibility of using cameras as rear view mirrors of the vehicle was explored.

% TODO x11
% TODO get pictures of display and camera used

The camera image would be displayed on a \verb|Waveshare 7" LCD| touchscreen.
To support that display the following section needs to be added to the \verb|config.txt| file.
\begin{lstlisting}
# Waveshare display rp4 setup
HDMI_GROUP = "2"
HDMI_MODE = "87"
HDMI_CVT = "1024 600 60 6 0 0 0"
HDMI_DRIVE = "1"

# Allow higher power draw for USB devices (makes display brighter)
MAX_USB_CURRENT = "1"
\end{lstlisting}

% TODO check command for showing camera image on screen (does it work?)
To show the camera output on screen we can run \verb|mpv /dev/video0|.

\subsubsection{Libraries}
Yocto offers built-in recipes for some of the libraries used by the telemetry application.
One of such libraries is \verb|libgpiod|, a library used to interact with \verb|GPIOs| on Linux systems.
To include this library we simply added it as a dependency of our project.

For libraries that don't have any existing recipes it is required to write a custom one.
In the case of the telemetry application, \verb|capnproto| was needed.
To add it to the project a \verb|capnbroto_1.1.0.bb| recipe file was created with the following contents:
\begin{lstlisting}
SUMMARY = "Cap'n Proto serialization/RPC system"
DESCRIPTION = "Capâ€™n Proto is an insanely fast data interchange format and capability-based RPC system. "
HOMEPAGE = "https://github.com/sandstorm-io/capnproto"
SECTION = "console/tools"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://../LICENSE;md5=a05663ae6cca874123bf667a60dca8c9"

SRC_URI = "git://github.com/capnproto/capnproto.git;" \
        "branch=release-${PV};protocol=https"
SRCREV = "b34ec28cceaf15b1082b74b50f03f770873c3636"

S = "${WORKDIR}/git/c++"

inherit cmake

CXXFLAGS:append:mips = " -latomic"
CXXFLAGS:append:powerpc = " -latomic"
CXXFLAGS:append:riscv32 = " -latomic"

EXTRA_OECMAKE += "\
    -DBUILD_TESTING=OFF \
"

FILES:${PN}-compiler = "${bindir}"

PACKAGE_BEFORE_PN = "${PN}-compiler"
RDEPENDS:${PN}-dev += "${PN}-compiler"

BBCLASSEXTEND = "native nativesdk"
\end{lstlisting}

This recipe clones the official \verb|capnproto| github repository and builds it from source using \verb|cmake|

\subsection{Telemetry Application}
\subsubsection{Overview}
% TODO describe the application
\begin{center}
    \begin{plantuml}
        @startuml
        component "Telemetry Application" as App

        ' Peripherals
        component CAN
        component "GPS Module" as GPS
        component RS485

        ' Outputs
        component CSV
        component "Base Station" as Station

        ' Inputs to the application
        CAN --> App
        GPS --> App
        RS485 --> App

        ' Output from the application
        App --> CSV
        App --> Station : LoRa

        note right of App
        Collects data from peripherals,
        periodically sends readings
        to base station via LoRa.
        Also saves readings to
        a local CSV file.
        end note

        @enduml
    \end{plantuml}
\end{center}

\subsubsection{Project Structure}
The simplified folder structure of the application looks like the following:
% TODO make this diagram more informative
% TODO instead of this, render the images in build.sh
\begin{center}
    \begin{plantuml}
        @startmindmap
        * rp4-telemetry
        ** build
        ** src
        *** threads
        ****_ can.cpp / .hpp
        ****_ csv.cpp / .hpp
        ****_ gps.cpp / .hpp
        ****_ lora.cpp / .hpp
        ****_ rs485.cpp / .hpp
        *** utils
        **** can_ids
        **** capnp-proto
        **** minmea
        **** rs485_parser
        **** rtc_watchdog
        ****_ data.cpp / .hpp
        ***_ main.cpp
        **_ CMakeLists.txt
        **_ README.md
        @endmindmap
    \end{plantuml}
\end{center}

\subsubsection{Peripherals}